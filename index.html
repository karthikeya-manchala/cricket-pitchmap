<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Cricket Field & Fielder Placement Visualizer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --field-radius-m: 68;
      --inner-circle-m: 27.432; /* 30 yards */
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f6f3ed;
      color: #222;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      min-height: 100vh;
    }

    h1 { margin: 16px 0 0; text-align: center; font-size: 1.8rem; }
    .subtitle { text-align: center; color: #666; margin: 4px 0 10px; font-size: 0.9rem; }

    .layout {
      display: flex;
      flex: 1;
      padding: 12px 16px 20px;
      gap: 16px;
    }

    @media (max-width: 900px) {
      .layout { flex-direction: column; }
    }

    .field-wrapper {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 400px;
    }

    .field-card {
      background: #ffffff;
      border-radius: 16px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.1);
      padding: 12px;
      width: 100%;
      max-width: 640px;
      aspect-ratio: 1 / 1;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #fieldSvg {
      width: 100%;
      height: 100%;
      touch-action: none;
    }

    .controls {
      flex: 0 0 320px;
      max-width: 360px;
      background: #ffffff;
      border-radius: 16px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.1);
      padding: 12px 14px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-height: calc(100vh - 120px);
    }

    @media (max-width: 900px) {
      .controls { max-width: 100%; max-height: none; }
    }

    .controls-section {
      margin-bottom: 8px;
      border-bottom: 1px solid #eee;
      padding-bottom: 8px;
    }
    .controls-section:last-of-type {
      border-bottom: none;
      padding-bottom: 0;
    }

    .controls-section h2 {
      font-size: 1rem;
      margin: 4px 0 6px;
    }

    .slider-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .slider-row span {
      font-size: 0.85rem;
      color: #555;
    }

    input[type="range"] {
      flex: 1;
    }

    label {
      font-size: 0.85rem;
    }

    .mirror-toggle,
    .small-row {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-top: 4px;
      cursor: pointer;
      font-size: 0.9rem;
    }

    .small-row {
      cursor: default;
      font-size: 0.8rem;
    }

    .note {
      font-size: 0.75rem;
      color: #777;
      margin-top: 2px;
    }

    .fielder-list {
      overflow-y: auto;
      padding-right: 4px;
      max-height: 55vh;
    }

    .fielder-row {
      border-radius: 10px;
      padding: 6px 8px;
      margin-bottom: 6px;
      background: #faf7f3;
      border: 1px solid #eee;
    }

    .fielder-row-header {
      font-size: 0.85rem;
      font-weight: 600;
      margin-bottom: 4px;
    }

    .fielder-row label {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 2px 0;
      font-size: 0.8rem;
    }

    .fielder-row input[type="text"] {
      flex: 1;
      margin-left: 6px;
      padding: 2px 4px;
      font-size: 0.8rem;
    }

    .fielder-row input[type="color"] {
      margin-left: 6px;
      width: 28px;
      height: 20px;
      padding: 0;
      border: none;
      background: transparent;
    }

    .fielder-row input[type="checkbox"] {
      margin-left: 6px;
    }

    /* Arrows & highlight controls */
    button {
      font-family: inherit;
      font-size: 0.8rem;
      padding: 4px 8px;
      border-radius: 8px;
      border: 1px solid #ddd;
      background: #f4f4f4;
      cursor: pointer;
    }

    button:hover {
      background: #e9e9e9;
    }

    .arrow-list {
      margin-top: 6px;
      max-height: 160px;
      overflow-y: auto;
    }

    .arrow-row {
      border-radius: 8px;
      border: 1px solid #eee;
      padding: 4px 6px;
      margin-top: 4px;
      background: #fafafa;
      font-size: 0.8rem;
    }

    .arrow-row-header {
      font-weight: 600;
      margin-bottom: 2px;
    }

    .arrow-row-controls {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-top: 2px;
    }

    .arrow-row-controls input[type="color"] {
      width: 24px;
      height: 18px;
      padding: 0;
      border: none;
      background: transparent;
    }

    .arrow-row-controls input[type="range"] {
      flex: 1;
    }

    /* SVG arrow styling */
    .arrow-line {
      cursor: pointer;
    }

    .arrow-handle {
      stroke-width: 0.3;
      cursor: pointer;
    }

    .fielder-circle {
      cursor: grab;
    }
  </style>
</head>
<body>
  <h1>Cricket Field Placement Visualizer</h1>
  <div class="subtitle">Drag fielders, add arrows, highlight sectors & mirror for different batters.</div>

  <div class="layout">
    <div class="field-wrapper">
      <div class="field-card">
        <svg id="fieldSvg" viewBox="-75 -75 150 150">
          <defs>
            <!-- per-arrow markers will be inserted here from JS -->
          </defs>

          <!-- Outer field (68m radius) -->
          <circle
            id="outerField"
            cx="0" cy="0" r="68"
            fill="#b7e0ab"
            stroke="#0b6820" stroke-width="0.7"
          ></circle>

          <!-- Outer border -->
          <circle
            id="outerBorder"
            cx="0" cy="0" r="68"
            fill="none"
            stroke="#1b4d1a"
            stroke-width="1"
          ></circle>

          <!-- Inner 30-yard circle -->
          <circle
            id="innerCircle"
            cx="0" cy="0" r="27.432"
            fill="none"
            stroke="#0b6820"
            stroke-dasharray="1.2 1.2"
            stroke-width="0.5"
          ></circle>

          <!-- Pitch (stays at center / wicket) -->
          <rect
            x="-2.5" y="-10" width="5" height="20"
            rx="1.5" ry="1.5"
            fill="#e0c6a2"
            stroke="#b89463"
            stroke-width="0.4"
          ></rect>

          <!-- Stumps -->
          <rect x="-0.6" y="-10.5" width="1.2" height="1.3" fill="#444"></rect>
          <rect x="-0.6" y="9.2"   width="1.2" height="1.3" fill="#444"></rect>

          <!-- Side labels (slightly smaller now) -->
          <text
            id="offLabel"
            x="-40" y="0"
            text-anchor="middle"
            dominant-baseline="middle"
            font-size="5"
            fill="#004b23"
            opacity="0.18"
            style="letter-spacing: 2px;"
          >OFF SIDE</text>

          <text
            id="legLabel"
            x="40" y="0"
            text-anchor="middle"
            dominant-baseline="middle"
            font-size="5"
            fill="#7f1d1d"
            opacity="0.18"
            style="letter-spacing: 2px;"
          >LEG SIDE</text>

          <!-- Sector highlight path (pie slice) -->
          <path id="sectorHighlight"
                fill="#facc15"
                opacity="0.3"
                stroke="none"></path>

          <!-- Wind legend -->
          <g id="windLegend">
            <rect
              x="40" y="-65" width="30" height="16"
              rx="3" ry="3"
              fill="#ffffff"
              opacity="0.85"
              stroke="#d4d4d4"
              stroke-width="0.3"
            ></rect>
            <text
              x="55" y="-63"
              text-anchor="middle"
              font-size="3.8"
              fill="#1d4ed8"
            >WIND</text>
            <g id="windArrow" transform="translate(55,-56)">
              <path d="M -8 0 L 6 0"
                    stroke="#2563eb"
                    stroke-width="1.2"
                    stroke-linecap="round"></path>
              <path d="M 6 0 L 3 -2 L 3 2 Z"
                    fill="#2563eb"></path>
              <path d="M -3 -2 C -4 -3 -5 -3 -6 -2"
                    stroke="#2563eb"
                    stroke-width="0.8"
                    fill="none"></path>
              <path d="M -3  2 C -4  3 -5  3 -6  2"
                    stroke="#2563eb"
                    stroke-width="0.8"
                    fill="none"></path>
            </g>
          </g>

          <!-- Arrows -->
          <g id="arrowsGroup"></g>

          <!-- Fielders -->
          <g id="fieldersGroup"></g>
        </svg>
      </div>
    </div>

    <div class="controls">
      <!-- Global settings -->
      <div class="controls-section">
        <h2>Global Settings</h2>

        <div class="slider-row">
          <span>Fielder size</span>
          <input type="range" id="sizeSlider" min="1" max="5" step="0.2" value="2.5" />
        </div>

        <div class="slider-row">
          <span>Boundary offset (m)</span>
          <input type="range" id="boundaryOffset" min="-10" max="10" step="1" value="0" />
        </div>
        <div class="note">
          Use about ±7m to simulate a short boundary on one side.
        </div>

        <label class="mirror-toggle">
          <input type="checkbox" id="mirrorToggle" />
          Mirror field (off/leg & fielders)
        </label>
        <label class="mirror-toggle">
          <input type="checkbox" id="hideAllLabels" />
          Hide all fielder labels
        </label>
      </div>

      <!-- Fielder controls -->
      <div class="controls-section">
        <h2>Fielder Controls</h2>
        <div class="note">Drag circles on the field. Edit label, color, highlight & visibility here.</div>
        <div class="fielder-list" id="fielderControls"></div>
      </div>

      <!-- Arrows & sector highlight -->
      <div class="controls-section">
        <h2>Arrows & Field Highlight</h2>

        <button type="button" id="addArrowBtn">Add arrow</button>
        <div class="note">Drag arrow body to move; drag round ends to resize & rotate.</div>
        <label class="small-row">
          <input type="checkbox" id="hideArrowHandles" />
          Hide arrow resize controls
        </label>
        <div id="arrowList" class="arrow-list"></div>

        <h3 style="margin-top:8px;font-size:0.9rem;">Sector highlight</h3>
        <label class="small-row">
          <input type="checkbox" id="sectorEnabled" />
          Enable sector (translucent yellow wedge)
        </label>
        <div class="slider-row">
          <span>Start angle</span>
          <input type="range" id="sectorStart" min="0" max="360" step="5" value="300" />
        </div>
        <div class="slider-row">
          <span>End angle</span>
          <input type="range" id="sectorEnd" min="0" max="360" step="5" value="40" />
        </div>
        <div class="note">Angles are from center, in degrees, around the full circle.</div>

        <h3 style="margin-top:8px;font-size:0.9rem;">Wind</h3>
        <label class="small-row">
          <input type="checkbox" id="windVisible" checked />
          Show wind legend
        </label>
        <div class="slider-row">
          <span>Wind direction</span>
          <input type="range" id="windDirection" min="0" max="360" step="15" value="0" />
        </div>
        <div class="note">0° = blowing to the right, 90° = up, 180° = left, 270° = down.</div>
      </div>
    </div>
  </div>

  <script>
    (function () {
      const SVG_NS = "http://www.w3.org/2000/svg";

      const svg = document.getElementById("fieldSvg");
      const defs = svg.querySelector("defs");
      const outerFieldCircle = document.getElementById("outerField");
      const outerBorderCircle = document.getElementById("outerBorder");
      const innerCircle = document.getElementById("innerCircle");

      const fieldersGroup = document.getElementById("fieldersGroup");
      const arrowsGroup = document.getElementById("arrowsGroup");
      const fielderControls = document.getElementById("fielderControls");
      const sizeSlider = document.getElementById("sizeSlider");
      const boundaryOffsetInput = document.getElementById("boundaryOffset");
      const mirrorToggle = document.getElementById("mirrorToggle");
      const hideAllLabels = document.getElementById("hideAllLabels");
      const offLabel = document.getElementById("offLabel");
      const legLabel = document.getElementById("legLabel");

      const addArrowBtn = document.getElementById("addArrowBtn");
      const hideArrowHandlesCheckbox = document.getElementById("hideArrowHandles");
      const arrowList = document.getElementById("arrowList");

      const sectorPath = document.getElementById("sectorHighlight");
      const sectorEnabledCheckbox = document.getElementById("sectorEnabled");
      const sectorStartInput = document.getElementById("sectorStart");
      const sectorEndInput = document.getElementById("sectorEnd");

      const windLegend = document.getElementById("windLegend");
      const windArrowGroup = document.getElementById("windArrow");
      const windVisibleCheckbox = document.getElementById("windVisible");
      const windDirectionInput = document.getElementById("windDirection");

      const FIELD_RADIUS = 68;
      const FIELDER_COUNT = 11;

      let fielderSize = parseFloat(sizeSlider.value);
      let isMirrored = false;
      let labelsHiddenAll = false;
      let fieldOffsetX = 0; // meters (SVG units)

      const fielders = [];
      let activeFielder = null;

      const pt = svg.createSVGPoint();

      // Arrows
      const arrows = [];
      let nextArrowId = 1;
      let activeArrow = null;
      let arrowDragMode = null; // "move" | "start" | "end"
      let prevArrowPointer = null;

      // Sector
      let sectorEnabled = false;
      let sectorStartDeg = parseFloat(sectorStartInput.value) || 0;
      let sectorEndDeg = parseFloat(sectorEndInput.value) || 0;

      function getSvgCoords(evt) {
        pt.x = evt.clientX;
        pt.y = evt.clientY;
        const ctm = svg.getScreenCTM();
        if (!ctm) return { x: 0, y: 0 };
        const inv = ctm.inverse();
        const p = pt.matrixTransform(inv);
        return { x: p.x, y: p.y };
      }

      function clampToCircle(x, y, radiusLimit) {
        const r = Math.sqrt(x * x + y * y);
        if (r <= radiusLimit) return { x, y };
        const scale = radiusLimit / r;
        return { x: x * scale, y: y * scale };
      }

      // FIELDERS -----------------------------------------------------------------
      function createInitialFielders() {
        const ring = 35; // radius for initial ring
        for (let i = 0; i < FIELDER_COUNT; i++) {
          const angle = (2 * Math.PI * i) / FIELDER_COUNT;
          const logicalX = ring * Math.cos(angle);
          const logicalY = ring * Math.sin(angle);

          const ringCircle = document.createElementNS(SVG_NS, "circle");
          ringCircle.setAttribute("fill", "none");
          ringCircle.setAttribute("stroke", "#ef4444");
          ringCircle.setAttribute("stroke-width", "0.5");
          ringCircle.style.display = "none";
          ringCircle.style.pointerEvents = "none";

          const circle = document.createElementNS(SVG_NS, "circle");
          circle.setAttribute("r", fielderSize.toString());
          circle.setAttribute("stroke", "#222");
          circle.setAttribute("stroke-width", "0.4");
          circle.setAttribute("fill", "#1d4ed8");
          circle.dataset.index = i.toString();
          circle.classList.add("fielder-circle");

          const label = document.createElementNS(SVG_NS, "text");
          label.setAttribute("text-anchor", "middle");
          label.setAttribute("dominant-baseline", "central");
          label.setAttribute("font-size", (fielderSize * 1.5).toString());
          label.setAttribute("fill", "#111");
          label.style.pointerEvents = "none";

          fieldersGroup.appendChild(ringCircle);
          fieldersGroup.appendChild(circle);
          fieldersGroup.appendChild(label);

          fielders.push({
            i,
            x: logicalX,
            y: logicalY,
            color: "#1d4ed8",
            name: "",
            hidden: false,
            highlight: false,
            ring: ringCircle,
            circle,
            label,
          });
        }

        updateAllFielders();
      }

      function updateSideLabels() {
        const offX = isMirrored ? 40 : -40;
        const legX = isMirrored ? -40 : 40;
        offLabel.setAttribute("x", offX.toString());
        legLabel.setAttribute("x", legX.toString());
      }

      function updateFielderVisual(f) {
        const displayX = isMirrored ? -f.x : f.x;
        const displayY = f.y;

        f.circle.setAttribute("cx", displayX.toString());
        f.circle.setAttribute("cy", displayY.toString());
        f.circle.setAttribute("r", fielderSize.toString());
        f.circle.setAttribute("fill", f.color);

        const txt = f.name.trim() || `F${f.i + 1}`;
        f.label.textContent = txt;
        f.label.setAttribute("x", displayX.toString());
        f.label.setAttribute(
          "y",
          (displayY - (fielderSize + 2.0)).toString()
        );
        f.label.setAttribute(
          "font-size",
          (fielderSize * 1.5).toString()
        );
        f.label.style.display =
          f.hidden || labelsHiddenAll ? "none" : "block";

        if (f.highlight) {
          f.ring.setAttribute("cx", displayX.toString());
          f.ring.setAttribute("cy", displayY.toString());
          f.ring.setAttribute("r", (fielderSize + 1.4).toString());
          f.ring.style.display = "block";
        } else {
          f.ring.style.display = "none";
        }
      }

      function updateAllFielders() {
        fielders.forEach(updateFielderVisual);
      }

      function buildFielderControls() {
        fielderControls.innerHTML = "";
        fielders.forEach((f) => {
          const row = document.createElement("div");
          row.className = "fielder-row";

          const header = document.createElement("div");
          header.className = "fielder-row-header";
          header.textContent = `Fielder ${f.i + 1}`;
          row.appendChild(header);

          const labelWrapper = document.createElement("label");
          labelWrapper.textContent = "Label";
          const labelInput = document.createElement("input");
          labelInput.type = "text";
          labelInput.placeholder = `F${f.i + 1}`;
          labelInput.value = f.name;
          labelInput.dataset.index = f.i.toString();
          labelWrapper.appendChild(labelInput);
          row.appendChild(labelWrapper);

          const colorWrapper = document.createElement("label");
          colorWrapper.textContent = "Color";
          const colorInput = document.createElement("input");
          colorInput.type = "color";
          colorInput.value = f.color;
          colorInput.dataset.index = f.i.toString();
          colorWrapper.appendChild(colorInput);
          row.appendChild(colorWrapper);

          const hideWrapper = document.createElement("label");
          hideWrapper.textContent = "Hide label";
          const hideInput = document.createElement("input");
          hideInput.type = "checkbox";
          hideInput.checked = f.hidden;
          hideInput.dataset.index = f.i.toString();
          hideWrapper.appendChild(hideInput);
          row.appendChild(hideWrapper);

          const highlightWrapper = document.createElement("label");
          highlightWrapper.textContent = "Highlight (red ring)";
          const highlightInput = document.createElement("input");
          highlightInput.type = "checkbox";
          highlightInput.checked = f.highlight;
          highlightInput.dataset.index = f.i.toString();
          highlightWrapper.appendChild(highlightInput);
          row.appendChild(highlightWrapper);

          fielderControls.appendChild(row);

          labelInput.addEventListener("input", (e) => {
            const idx = parseInt(e.target.dataset.index, 10);
            const ff = fielders[idx];
            ff.name = e.target.value;
            updateFielderVisual(ff);
          });

          colorInput.addEventListener("input", (e) => {
            const idx = parseInt(e.target.dataset.index, 10);
            const ff = fielders[idx];
            ff.color = e.target.value;
            updateFielderVisual(ff);
          });

          hideInput.addEventListener("change", (e) => {
            const idx = parseInt(e.target.dataset.index, 10);
            const ff = fielders[idx];
            ff.hidden = e.target.checked;
            updateFielderVisual(ff);
          });

          highlightInput.addEventListener("change", (e) => {
            const idx = parseInt(e.target.dataset.index, 10);
            const ff = fielders[idx];
            ff.highlight = e.target.checked;
            updateFielderVisual(ff);
          });
        });
      }

      // BOUNDARY OFFSET ----------------------------------------------------------
      function updateFieldOffset() {
        fieldOffsetX = parseFloat(boundaryOffsetInput.value) || 0;
        outerFieldCircle.setAttribute("cx", fieldOffsetX.toString());
        outerBorderCircle.setAttribute("cx", fieldOffsetX.toString());
        innerCircle.setAttribute("cx", fieldOffsetX.toString());
        updateSectorPath();
      }

      // ARROWS -------------------------------------------------------------------
      function getArrowById(id) {
        return arrows.find((a) => a.id === id);
      }

      function updateArrowVisual(arrow) {
        arrow.lineEl.setAttribute("x1", arrow.x1.toString());
        arrow.lineEl.setAttribute("y1", arrow.y1.toString());
        arrow.lineEl.setAttribute("x2", arrow.x2.toString());
        arrow.lineEl.setAttribute("y2", arrow.y2.toString());
        arrow.lineEl.setAttribute("stroke", arrow.color);
        arrow.lineEl.setAttribute("stroke-width", arrow.width.toString());
        arrow.lineEl.setAttribute("opacity", arrow.opacity.toString());

        if (arrow.markerPathEl) {
          arrow.markerPathEl.setAttribute("fill", arrow.color);
        }

        arrow.handleStartEl.setAttribute("stroke", arrow.color);
        arrow.handleEndEl.setAttribute("stroke", arrow.color);
        arrow.handleStartEl.setAttribute("fill", arrow.color);
        arrow.handleEndEl.setAttribute("fill", arrow.color);

        arrow.handleStartEl.setAttribute("cx", arrow.x1.toString());
        arrow.handleStartEl.setAttribute("cy", arrow.y1.toString());
        arrow.handleEndEl.setAttribute("cx", arrow.x2.toString());
        arrow.handleEndEl.setAttribute("cy", arrow.y2.toString());
      }

      function updateHandlesVisibilityGlobal() {
        const hide = hideArrowHandlesCheckbox.checked;
        arrows.forEach((arrow) => {
          arrow.handleStartEl.style.display = hide ? "none" : "block";
          arrow.handleEndEl.style.display = hide ? "none" : "block";
        });
      }

      function rebuildArrowList() {
        arrowList.innerHTML = "";
        arrows.forEach((arrow, idx) => {
          const row = document.createElement("div");
          row.className = "arrow-row";

          const header = document.createElement("div");
          header.className = "arrow-row-header";
          header.textContent = `Arrow ${idx + 1}`;
          row.appendChild(header);

          const controls = document.createElement("div");
          controls.className = "arrow-row-controls";

          const colorLabel = document.createElement("span");
          colorLabel.textContent = "Color";
          colorLabel.style.fontSize = "0.75rem";

          const colorInput = document.createElement("input");
          colorInput.type = "color";
          colorInput.value = arrow.color;

          const widthLabel = document.createElement("span");
          widthLabel.textContent = "Width";
          widthLabel.style.fontSize = "0.75rem";

          const widthInput = document.createElement("input");
          widthInput.type = "range";
          widthInput.min = "0.4";
          widthInput.max = "3";
          widthInput.step = "0.1";
          widthInput.value = arrow.width.toString();

          const deleteBtn = document.createElement("button");
          deleteBtn.type = "button";
          deleteBtn.textContent = "Delete";

          controls.appendChild(colorLabel);
          controls.appendChild(colorInput);
          controls.appendChild(widthLabel);
          controls.appendChild(widthInput);
          controls.appendChild(deleteBtn);

          row.appendChild(controls);
          arrowList.appendChild(row);

          colorInput.addEventListener("input", () => {
            arrow.color = colorInput.value;
            updateArrowVisual(arrow);
          });

          widthInput.addEventListener("input", () => {
            arrow.width = parseFloat(widthInput.value);
            updateArrowVisual(arrow);
          });

          deleteBtn.addEventListener("click", () => {
            arrowsGroup.removeChild(arrow.lineEl);
            arrowsGroup.removeChild(arrow.handleStartEl);
            arrowsGroup.removeChild(arrow.handleEndEl);
            if (arrow.markerEl && defs.contains(arrow.markerEl)) {
              defs.removeChild(arrow.markerEl);
            }
            const idxInArr = arrows.findIndex((a) => a.id === arrow.id);
            if (idxInArr >= 0) arrows.splice(idxInArr, 1);
            rebuildArrowList();
          });
        });
      }

      function createArrow() {
        const id = nextArrowId++;
        const x1 = -10;
        const y1 = 0;
        const x2 = 10;
        const y2 = 0;
        const baseColor = "#b91c1c";

        const line = document.createElementNS(SVG_NS, "line");
        line.classList.add("arrow-line");
        line.dataset.id = id.toString();
        line.setAttribute("x1", x1.toString());
        line.setAttribute("y1", y1.toString());
        line.setAttribute("x2", x2.toString());
        line.setAttribute("y2", y2.toString());
        line.setAttribute("stroke", baseColor);
        line.setAttribute("stroke-width", "1.2");
        line.setAttribute("opacity", "0.85");

        const markerId = "arrowHead-" + id;
        const marker = document.createElementNS(SVG_NS, "marker");
        marker.setAttribute("id", markerId);
        marker.setAttribute("viewBox", "0 0 10 10");
        marker.setAttribute("refX", "9");
        marker.setAttribute("refY", "5");
        marker.setAttribute("markerWidth", "4");
        marker.setAttribute("markerHeight", "4");
        marker.setAttribute("orient", "auto-start-reverse");

        const markerPath = document.createElementNS(SVG_NS, "path");
        markerPath.setAttribute("d", "M 0 0 L 10 5 L 0 10 z");
        markerPath.setAttribute("fill", baseColor);
        marker.appendChild(markerPath);
        defs.appendChild(marker);

        line.setAttribute("marker-end", "url(#" + markerId + ")");

        const handleStart = document.createElementNS(SVG_NS, "circle");
        handleStart.classList.add("arrow-handle");
        handleStart.dataset.id = id.toString();
        handleStart.dataset.handle = "start";
        handleStart.setAttribute("r", "1.4");

        const handleEnd = document.createElementNS(SVG_NS, "circle");
        handleEnd.classList.add("arrow-handle");
        handleEnd.dataset.id = id.toString();
        handleEnd.dataset.handle = "end";
        handleEnd.setAttribute("r", "1.4");

        arrowsGroup.appendChild(line);
        arrowsGroup.appendChild(handleStart);
        arrowsGroup.appendChild(handleEnd);

        const arrow = {
          id,
          x1,
          y1,
          x2,
          y2,
          color: baseColor,
          width: 1.2,
          opacity: 0.85,
          lineEl: line,
          handleStartEl: handleStart,
          handleEndEl: handleEnd,
          markerEl: marker,
          markerPathEl: markerPath,
        };
        arrows.push(arrow);
        updateArrowVisual(arrow);
        rebuildArrowList();
        updateHandlesVisibilityGlobal();
      }

      function arrowPointerDown(evt, target) {
        const id = parseInt(target.dataset.id || "-1", 10);
        if (isNaN(id)) return;
        const arrow = getArrowById(id);
        if (!arrow) return;

        activeArrow = arrow;
        if (target.classList.contains("arrow-line")) {
          arrowDragMode = "move";
        } else {
          arrowDragMode = target.dataset.handle === "start" ? "start" : "end";
        }

        prevArrowPointer = getSvgCoords(evt);
        evt.preventDefault();
      }

      function arrowPointerMove(evt) {
        if (!activeArrow || !arrowDragMode) return;
        const p = getSvgCoords(evt);

        if (arrowDragMode === "move") {
          const dx = p.x - prevArrowPointer.x;
          const dy = p.y - prevArrowPointer.y;
          prevArrowPointer = p;

          const p1 = clampToCircle(
            activeArrow.x1 + dx,
            activeArrow.y1 + dy,
            FIELD_RADIUS
          );
          const p2 = clampToCircle(
            activeArrow.x2 + dx,
            activeArrow.y2 + dy,
            FIELD_RADIUS
          );
          activeArrow.x1 = p1.x;
          activeArrow.y1 = p1.y;
          activeArrow.x2 = p2.x;
          activeArrow.y2 = p2.y;
        } else if (arrowDragMode === "start") {
          const p1 = clampToCircle(p.x, p.y, FIELD_RADIUS);
          activeArrow.x1 = p1.x;
          activeArrow.y1 = p1.y;
        } else if (arrowDragMode === "end") {
          const p2 = clampToCircle(p.x, p.y, FIELD_RADIUS);
          activeArrow.x2 = p2.x;
          activeArrow.y2 = p2.y;
        }

        updateArrowVisual(activeArrow);
      }

      // SECTOR / PIE HIGHLIGHT ---------------------------------------------------
      function degToRad(deg) {
        return (deg * Math.PI) / 180;
      }

      function updateSectorPath() {
        if (!sectorEnabled) {
          sectorPath.style.display = "none";
          sectorPath.setAttribute("d", "");
          return;
        }

        sectorPath.style.display = "block";

        let start = sectorStartDeg % 360;
        let end = sectorEndDeg % 360;
        if (start < 0) start += 360;
        if (end < 0) end += 360;

        let delta = end - start;
        if (delta <= 0) {
          delta += 360;
        }
        const largeArcFlag = delta > 180 ? 1 : 0;
        const sweepFlag = 1;

        const R = FIELD_RADIUS;
        const CX = fieldOffsetX; // center of field circle (offset)
        const startRad = degToRad(start);
        const endRad = degToRad(end);

        const x1 = CX + R * Math.cos(startRad);
        const y1 = R * Math.sin(startRad);
        const x2 = CX + R * Math.cos(endRad);
        const y2 = R * Math.sin(endRad);

        const d = [
          "M", CX, 0,
          "L", x1, y1,
          "A", R, R, 0, largeArcFlag, sweepFlag, x2, y2,
          "Z"
        ].join(" ");

        sectorPath.setAttribute("d", d);
      }

      // WIND LEGEND --------------------------------------------------------------
      function updateWindVisibility() {
        windLegend.style.display = windVisibleCheckbox.checked ? "block" : "none";
      }

      function updateWindDirection() {
        const angle = parseFloat(windDirectionInput.value) || 0;
        // rotate around its anchor (55, -56)
        windArrowGroup.setAttribute(
          "transform",
          "translate(55,-56) rotate(" + angle + ")"
        );
      }

      // POINTER HANDLING ---------------------------------------------------------
      function handlePointerDown(evt) {
        const target = evt.target;

        if (
          target.classList.contains("arrow-line") ||
          target.classList.contains("arrow-handle")
        ) {
          arrowPointerDown(evt, target);
          return;
        }

        if (target.classList.contains("fielder-circle")) {
          const idx = parseInt(target.dataset.index || "-1", 10);
          if (!isNaN(idx) && idx >= 0 && idx < fielders.length) {
            activeFielder = fielders[idx];
            target.style.cursor = "grabbing";
            evt.preventDefault();
          }
          return;
        }
      }

      function handlePointerMove(evt) {
        if (activeFielder) {
          const { x, y } = getSvgCoords(evt);
          const clamped = clampToCircle(
            x,
            y,
            FIELD_RADIUS - fielderSize * 0.8
          );
          const displayX = clamped.x;
          const displayY = clamped.y;
          activeFielder.x = isMirrored ? -displayX : displayX;
          activeFielder.y = displayY;
          updateFielderVisual(activeFielder);
        }

        if (activeArrow) {
          arrowPointerMove(evt);
        }
      }

      function handlePointerUp() {
        if (activeFielder && activeFielder.circle) {
          activeFielder.circle.style.cursor = "grab";
        }
        activeFielder = null;

        activeArrow = null;
        arrowDragMode = null;
        prevArrowPointer = null;
      }

      // EVENTS -------------------------------------------------------------------
      svg.addEventListener("pointerdown", handlePointerDown);
      svg.addEventListener("pointermove", handlePointerMove);
      svg.addEventListener("pointerup", handlePointerUp);
      svg.addEventListener("pointerleave", handlePointerUp);

      sizeSlider.addEventListener("input", () => {
        fielderSize = parseFloat(sizeSlider.value);
        updateAllFielders();
      });

      boundaryOffsetInput.addEventListener("input", () => {
        updateFieldOffset();
      });

      mirrorToggle.addEventListener("change", () => {
        isMirrored = mirrorToggle.checked;
        updateSideLabels();
        updateAllFielders();
      });

      hideAllLabels.addEventListener("change", () => {
        labelsHiddenAll = hideAllLabels.checked;
        updateAllFielders();
      });

      addArrowBtn.addEventListener("click", () => {
        createArrow();
      });

      hideArrowHandlesCheckbox.addEventListener("change", () => {
        updateHandlesVisibilityGlobal();
      });

      sectorEnabledCheckbox.addEventListener("change", () => {
        sectorEnabled = sectorEnabledCheckbox.checked;
        updateSectorPath();
      });

      sectorStartInput.addEventListener("input", () => {
        sectorStartDeg = parseFloat(sectorStartInput.value) || 0;
        updateSectorPath();
      });

      sectorEndInput.addEventListener("input", () => {
        sectorEndDeg = parseFloat(sectorEndInput.value) || 0;
        updateSectorPath();
      });

      windVisibleCheckbox.addEventListener("change", () => {
        updateWindVisibility();
      });

      windDirectionInput.addEventListener("input", () => {
        updateWindDirection();
      });

      // INIT ---------------------------------------------------------------------
      createInitialFielders();
      buildFielderControls();
      updateSideLabels();
      updateFieldOffset();
      updateSectorPath();
      updateWindVisibility();
      updateWindDirection();
    })();
  </script>
</body>
</html>
